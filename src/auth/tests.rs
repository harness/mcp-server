#[cfg(test)]\nmod tests {\n    use super::*;\n    use chrono::{Duration, Utc};\n    use jsonwebtoken::{encode, EncodingKey, Header};\n    use std::collections::HashMap;\n\n    #[test]\n    fn test_extract_account_id_from_api_key() {\n        // Valid API key\n        let api_key = \"pat.account123.token456.signature789\";\n        let result = AuthSession::extract_account_id_from_api_key(api_key);\n        assert!(result.is_ok());\n        assert_eq!(result.unwrap(), \"account123\");\n        \n        // Invalid format - missing parts\n        let invalid_key = \"pat.account123\";\n        let result = AuthSession::extract_account_id_from_api_key(invalid_key);\n        assert!(result.is_err());\n        \n        // Invalid format - wrong prefix\n        let invalid_key = \"token.account123.token456.signature789\";\n        let result = AuthSession::extract_account_id_from_api_key(invalid_key);\n        assert!(result.is_err());\n        \n        // Invalid format - empty account ID\n        let invalid_key = \"pat..token456.signature789\";\n        let result = AuthSession::extract_account_id_from_api_key(invalid_key);\n        assert!(result.is_err());\n    }\n    \n    #[test]\n    fn test_validate_api_key_format() {\n        // Valid API key\n        let api_key = \"pat.account123.token456.signature789\";\n        let result = AuthSession::validate_api_key_format(api_key);\n        assert!(result.is_ok());\n        \n        // Invalid API key\n        let invalid_key = \"invalid_key\";\n        let result = AuthSession::validate_api_key_format(invalid_key);\n        assert!(result.is_err());\n    }\n    \n    #[test]\n    fn test_from_api_key() {\n        let api_key = \"pat.account123.token456.signature789\";\n        let result = AuthSession::from_api_key(api_key);\n        \n        assert!(result.is_ok());\n        let session = result.unwrap();\n        \n        assert_eq!(session.principal.account_id, \"account123\");\n        assert_eq!(session.token_type, TokenType::ApiKey);\n        assert_eq!(session.token, api_key);\n        assert!(session.expires_at.is_none());\n        assert!(session.has_scope(\"*\"));\n    }\n    \n    #[test]\n    fn test_session_expiration() {\n        let api_key = \"pat.account123.token456.signature789\";\n        let mut session = AuthSession::from_api_key(api_key).unwrap();\n        \n        // API key sessions don't expire\n        assert!(!session.is_expired());\n        \n        // Set expiration in the past\n        session.expires_at = Some(Utc::now() - Duration::hours(1));\n        assert!(session.is_expired());\n        \n        // Set expiration in the future\n        session.expires_at = Some(Utc::now() + Duration::hours(1));\n        assert!(!session.is_expired());\n    }\n    \n    #[test]\n    fn test_scope_checking() {\n        let api_key = \"pat.account123.token456.signature789\";\n        let mut session = AuthSession::from_api_key(api_key).unwrap();\n        \n        // API key has wildcard scope\n        assert!(session.has_scope(\"read\"));\n        assert!(session.has_scope(\"write\"));\n        assert!(session.has_scope(\"admin\"));\n        \n        // Set specific scopes\n        session.scopes = vec![\"read\".to_string(), \"write\".to_string()];\n        assert!(session.has_scope(\"read\"));\n        assert!(session.has_scope(\"write\"));\n        assert!(!session.has_scope(\"admin\"));\n    }\n    \n    #[test]\n    fn test_permission_checking() {\n        let api_key = \"pat.account123.token456.signature789\";\n        let mut session = AuthSession::from_api_key(api_key).unwrap();\n        \n        // API key with wildcard scope has all permissions\n        assert!(session.has_permission(\"pipelines\", \"read\"));\n        assert!(session.has_permission(\"connectors\", \"write\"));\n        \n        // Set specific permissions\n        let mut permissions = HashMap::new();\n        permissions.insert(\"pipelines\".to_string(), vec![\"read\".to_string()]);\n        permissions.insert(\"connectors\".to_string(), vec![\"read\".to_string(), \"write\".to_string()]);\n        \n        session.permissions = permissions;\n        session.scopes = vec![\"limited\".to_string()]; // Remove wildcard\n        \n        assert!(session.has_permission(\"pipelines\", \"read\"));\n        assert!(!session.has_permission(\"pipelines\", \"write\"));\n        assert!(session.has_permission(\"connectors\", \"read\"));\n        assert!(session.has_permission(\"connectors\", \"write\"));\n        assert!(!session.has_permission(\"secrets\", \"read\"));\n    }\n    \n    #[test]\n    fn test_get_auth_header() {\n        // API key session\n        let api_key = \"pat.account123.token456.signature789\";\n        let session = AuthSession::from_api_key(api_key).unwrap();\n        let (header_name, header_value) = session.get_auth_header();\n        assert_eq!(header_name, \"x-api-key\");\n        assert_eq!(header_value, api_key);\n        \n        // Bearer token session\n        let mut session = session;\n        session.token_type = TokenType::BearerToken;\n        session.token = \"jwt_token_here\".to_string();\n        let (header_name, header_value) = session.get_auth_header();\n        assert_eq!(header_name, \"Authorization\");\n        assert_eq!(header_value, \"Bearer jwt_token_here\");\n    }\n    \n    #[tokio::test]\n    async fn test_jwt_authentication() {\n        let secret = \"test_secret\";\n        let account_id = \"test_account\";\n        \n        // Create a test JWT token\n        let claims = JwtClaims {\n            sub: \"user123\".to_string(),\n            account_id: account_id.to_string(),\n            email: Some(\"test@example.com\".to_string()),\n            name: Some(\"Test User\".to_string()),\n            user_type: Some(\"USER\".to_string()),\n            scopes: Some(vec![\"read\".to_string(), \"write\".to_string()]),\n            permissions: Some(HashMap::new()),\n            exp: (Utc::now() + Duration::hours(1)).timestamp() as usize,\n            iat: Some(Utc::now().timestamp() as usize),\n            iss: Some(\"harness\".to_string()),\n            aud: Some(\"mcp-server\".to_string()),\n        };\n        \n        let token = encode(\n            &Header::default(),\n            &claims,\n            &EncodingKey::from_secret(secret.as_ref()),\n        ).unwrap();\n        \n        // Test authentication\n        let result = AuthSession::authenticate(&token, secret).await;\n        assert!(result.is_ok());\n        \n        let session = result.unwrap();\n        assert_eq!(session.principal.account_id, account_id);\n        assert_eq!(session.principal.user_id, Some(\"user123\".to_string()));\n        assert_eq!(session.principal.email, Some(\"test@example.com\".to_string()));\n        assert_eq!(session.token_type, TokenType::BearerToken);\n        assert!(session.has_scope(\"read\"));\n        assert!(session.has_scope(\"write\"));\n        assert!(!session.has_scope(\"admin\"));\n    }\n    \n    #[tokio::test]\n    async fn test_jwt_authentication_expired() {\n        let secret = \"test_secret\";\n        \n        // Create an expired JWT token\n        let claims = JwtClaims {\n            sub: \"user123\".to_string(),\n            account_id: \"test_account\".to_string(),\n            email: None,\n            name: None,\n            user_type: None,\n            scopes: None,\n            permissions: None,\n            exp: (Utc::now() - Duration::hours(1)).timestamp() as usize, // Expired\n            iat: Some((Utc::now() - Duration::hours(2)).timestamp() as usize),\n            iss: None,\n            aud: None,\n        };\n        \n        let token = encode(\n            &Header::default(),\n            &claims,\n            &EncodingKey::from_secret(secret.as_ref()),\n        ).unwrap();\n        \n        // Test authentication with expired token\n        let result = AuthSession::authenticate(&token, secret).await;\n        assert!(result.is_err());\n    }\n    \n    #[tokio::test]\n    async fn test_jwt_authentication_invalid_secret() {\n        let secret = \"test_secret\";\n        let wrong_secret = \"wrong_secret\";\n        \n        // Create a JWT token with one secret\n        let claims = JwtClaims {\n            sub: \"user123\".to_string(),\n            account_id: \"test_account\".to_string(),\n            email: None,\n            name: None,\n            user_type: None,\n            scopes: None,\n            permissions: None,\n            exp: (Utc::now() + Duration::hours(1)).timestamp() as usize,\n            iat: Some(Utc::now().timestamp() as usize),\n            iss: None,\n            aud: None,\n        };\n        \n        let token = encode(\n            &Header::default(),\n            &claims,\n            &EncodingKey::from_secret(secret.as_ref()),\n        ).unwrap();\n        \n        // Test authentication with wrong secret\n        let result = AuthSession::authenticate(&token, wrong_secret).await;\n        assert!(result.is_err());\n    }\n}"