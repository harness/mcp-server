// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package generated

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
)

const (
	X_Api_Key_header_X_Api_KeyScopes = "X_Api_Key_header_X_Api_Key.Scopes"
	Jwt_header_AuthorizationScopes   = "jwt_header_Authorization.Scopes"
)

// Defines values for AllIssueSummarySeverityCode.
const (
	AllIssueSummarySeverityCodeCritical   AllIssueSummarySeverityCode = "Critical"
	AllIssueSummarySeverityCodeHigh       AllIssueSummarySeverityCode = "High"
	AllIssueSummarySeverityCodeInfo       AllIssueSummarySeverityCode = "Info"
	AllIssueSummarySeverityCodeLow        AllIssueSummarySeverityCode = "Low"
	AllIssueSummarySeverityCodeMedium     AllIssueSummarySeverityCode = "Medium"
	AllIssueSummarySeverityCodeUnassigned AllIssueSummarySeverityCode = "Unassigned"
)

// Defines values for ExemptionCanApproveFor.
const (
	ExemptionCanApproveForACCOUNT  ExemptionCanApproveFor = "ACCOUNT"
	ExemptionCanApproveForORG      ExemptionCanApproveFor = "ORG"
	ExemptionCanApproveForPIPELINE ExemptionCanApproveFor = "PIPELINE"
	ExemptionCanApproveForPROJECT  ExemptionCanApproveFor = "PROJECT"
	ExemptionCanApproveForTARGET   ExemptionCanApproveFor = "TARGET"
)

// Defines values for ExemptionExemptionStatusAtScan.
const (
	ExemptionExemptionStatusAtScanApproved ExemptionExemptionStatusAtScan = "Approved"
	ExemptionExemptionStatusAtScanExpired  ExemptionExemptionStatusAtScan = "Expired"
	ExemptionExemptionStatusAtScanPending  ExemptionExemptionStatusAtScan = "Pending"
	ExemptionExemptionStatusAtScanRejected ExemptionExemptionStatusAtScan = "Rejected"
)

// Defines values for ExemptionScope.
const (
	ExemptionScopeACCOUNT  ExemptionScope = "ACCOUNT"
	ExemptionScopeORG      ExemptionScope = "ORG"
	ExemptionScopePIPELINE ExemptionScope = "PIPELINE"
	ExemptionScopePROJECT  ExemptionScope = "PROJECT"
	ExemptionScopeTARGET   ExemptionScope = "TARGET"
)

// Defines values for ExemptionStatus.
const (
	ExemptionStatusApproved ExemptionStatus = "Approved"
	ExemptionStatusCanceled ExemptionStatus = "Canceled"
	ExemptionStatusExpired  ExemptionStatus = "Expired"
	ExemptionStatusPending  ExemptionStatus = "Pending"
	ExemptionStatusRejected ExemptionStatus = "Rejected"
)

// Defines values for ExemptionType.
const (
	ExemptionTypeAcceptableRisk       ExemptionType = "Acceptable Risk"
	ExemptionTypeAcceptableUse        ExemptionType = "Acceptable Use"
	ExemptionTypeCompensatingControls ExemptionType = "Compensating Controls"
	ExemptionTypeFalsePositive        ExemptionType = "False Positive"
	ExemptionTypeFixUnavailable       ExemptionType = "Fix Unavailable"
	ExemptionTypeOther                ExemptionType = "Other"
)

// Defines values for FrontendExemptionCanApproveFor.
const (
	FrontendExemptionCanApproveForACCOUNT  FrontendExemptionCanApproveFor = "ACCOUNT"
	FrontendExemptionCanApproveForORG      FrontendExemptionCanApproveFor = "ORG"
	FrontendExemptionCanApproveForPIPELINE FrontendExemptionCanApproveFor = "PIPELINE"
	FrontendExemptionCanApproveForPROJECT  FrontendExemptionCanApproveFor = "PROJECT"
	FrontendExemptionCanApproveForTARGET   FrontendExemptionCanApproveFor = "TARGET"
)

// Defines values for FrontendExemptionScope.
const (
	FrontendExemptionScopeACCOUNT  FrontendExemptionScope = "ACCOUNT"
	FrontendExemptionScopeORG      FrontendExemptionScope = "ORG"
	FrontendExemptionScopePIPELINE FrontendExemptionScope = "PIPELINE"
	FrontendExemptionScopePROJECT  FrontendExemptionScope = "PROJECT"
	FrontendExemptionScopeTARGET   FrontendExemptionScope = "TARGET"
)

// Defines values for IssueSummaryCurrentStatus.
const (
	IssueSummaryCurrentStatusApproved IssueSummaryCurrentStatus = "Approved"
	IssueSummaryCurrentStatusExpired  IssueSummaryCurrentStatus = "Expired"
	IssueSummaryCurrentStatusPending  IssueSummaryCurrentStatus = "Pending"
	IssueSummaryCurrentStatusRejected IssueSummaryCurrentStatus = "Rejected"
)

// Defines values for IssueSummaryExemptionStatusAtScan.
const (
	IssueSummaryExemptionStatusAtScanApproved IssueSummaryExemptionStatusAtScan = "Approved"
	IssueSummaryExemptionStatusAtScanExpired  IssueSummaryExemptionStatusAtScan = "Expired"
	IssueSummaryExemptionStatusAtScanPending  IssueSummaryExemptionStatusAtScan = "Pending"
	IssueSummaryExemptionStatusAtScanRejected IssueSummaryExemptionStatusAtScan = "Rejected"
)

// Defines values for IssueSummarySeverityCode.
const (
	IssueSummarySeverityCodeCritical   IssueSummarySeverityCode = "Critical"
	IssueSummarySeverityCodeHigh       IssueSummarySeverityCode = "High"
	IssueSummarySeverityCodeInfo       IssueSummarySeverityCode = "Info"
	IssueSummarySeverityCodeLow        IssueSummarySeverityCode = "Low"
	IssueSummarySeverityCodeMedium     IssueSummarySeverityCode = "Medium"
	IssueSummarySeverityCodeUnassigned IssueSummarySeverityCode = "Unassigned"
)

// Defines values for IssueSummaryStatus.
const (
	IssueSummaryStatusAcceptableRisk       IssueSummaryStatus = "Acceptable Risk"
	IssueSummaryStatusAcceptableUse        IssueSummaryStatus = "Acceptable Use"
	IssueSummaryStatusCompensatingControls IssueSummaryStatus = "Compensating Controls"
	IssueSummaryStatusExempted             IssueSummaryStatus = "Exempted"
	IssueSummaryStatusFalsePositive        IssueSummaryStatus = "False Positive"
	IssueSummaryStatusFixUnavailable       IssueSummaryStatus = "Fix Unavailable"
	IssueSummaryStatusRemediated           IssueSummaryStatus = "Remediated"
)

// Defines values for IssueSummaryType.
const (
	BUGSMELLS      IssueSummaryType = "BUG_SMELLS"
	CODECOVERAGE   IssueSummaryType = "CODE_COVERAGE"
	CODESMELLS     IssueSummaryType = "CODE_SMELLS"
	DAST           IssueSummaryType = "DAST"
	EXTERNALPOLICY IssueSummaryType = "EXTERNAL_POLICY"
	IAC            IssueSummaryType = "IAC"
	MISCONFIG      IssueSummaryType = "MISCONFIG"
	SAST           IssueSummaryType = "SAST"
	SCA            IssueSummaryType = "SCA"
	SECRET         IssueSummaryType = "SECRET"
)

// Defines values for ExemptionsApproveExemptionParamsAction.
const (
	Approve ExemptionsApproveExemptionParamsAction = "approve"
	Reject  ExemptionsApproveExemptionParamsAction = "reject"
)

// Defines values for FrontendGlobalExemptionsParamsStatus.
const (
	Approved FrontendGlobalExemptionsParamsStatus = "Approved"
	Canceled FrontendGlobalExemptionsParamsStatus = "Canceled"
	Expired  FrontendGlobalExemptionsParamsStatus = "Expired"
	Pending  FrontendGlobalExemptionsParamsStatus = "Pending"
	Rejected FrontendGlobalExemptionsParamsStatus = "Rejected"
)

// AllIssueSummary All issue summary
type AllIssueSummary struct {
	// ExemptionExpiration Unix timestamp at which this Exemption will expire
	ExemptionExpiration *int64 `json:"exemptionExpiration,omitempty"`

	// ExemptionId ID of Security Test Exemption
	ExemptionId *string `json:"exemptionId,omitempty"`

	// ExemptionStatus Status of project scoped exemption for this issue
	ExemptionStatus *string `json:"exemptionStatus,omitempty"`

	// Id Resource identifier
	Id string `json:"id"`

	// IssueType Issue Type
	IssueType *string `json:"issueType,omitempty"`

	// LastDetected Timestamp of the last detection of this issue
	LastDetected int64 `json:"lastDetected"`

	// NumOccurrences Number of occurrences of this issue against the latest baseline scan
	NumOccurrences float32 `json:"numOccurrences"`

	// NumTargetsImpacted Number of targets impacted where this issue was found against the latest baseline scan
	NumTargetsImpacted float32 `json:"numTargetsImpacted"`

	// Override Indicates the issue has been overridden
	Override *map[string]interface{} `json:"override,omitempty"`

	// SeverityCode Severity code
	SeverityCode AllIssueSummarySeverityCode `json:"severityCode"`

	// Title Title of the Security Issue
	Title string `json:"title"`
}

// AllIssueSummarySeverityCode Severity code
type AllIssueSummarySeverityCode string

// AllIssuesListResult defines model for AllIssuesListResult.
type AllIssuesListResult struct {
	// Issues Issues related to the latest scans of a baseline in a specific project
	Issues     []AllIssueSummary `json:"issues"`
	Pagination Pagination        `json:"pagination"`
}

// ApproveExemptionRequestBody defines model for ApproveExemptionRequestBody.
type ApproveExemptionRequestBody struct {
	// ApproverId User ID the user who approved or rejected this exemptions
	ApproverId string `json:"approverId"`

	// Comment Comment to be added to the Exemption approval or rejection
	Comment *string `json:"comment,omitempty"`
}

// Exemption Information about an Exemption
type Exemption struct {
	// ApproverId User ID the user who approved or rejected this exemptions
	ApproverId *string `json:"approverId,omitempty"`

	// CanApproveFor Consists of RBAC scopes for an user associated with this Exemption
	CanApproveFor *[]ExemptionCanApproveFor `json:"canApproveFor,omitempty"`

	// CanCancel States if the user can cancel the exemption
	CanCancel *bool `json:"canCancel,omitempty"`

	// CanCreate States whether the user can create or reopen the exemption
	CanCreate *bool `json:"canCreate,omitempty"`

	// CanReApprove States if the user can re-approve the exemption for the exemption's scope
	CanReApprove *bool `json:"canReApprove,omitempty"`

	// CanReject States whether the user can reject the exemption
	CanReject *bool `json:"canReject,omitempty"`

	// Comment The additional comment to include with the exemption
	Comment *string `json:"comment,omitempty"`

	// Created Unix timestamp at which the resource was created
	Created int64 `json:"created"`

	// ExemptionStatusAtScan Exemption's status at the Security Scan created time
	ExemptionStatusAtScan *ExemptionExemptionStatusAtScan `json:"exemptionStatusAtScan,omitempty"`

	// Expiration Unix timestamp at which this Exemption will expire
	Expiration *int64 `json:"expiration,omitempty"`

	// Id Resource identifier
	Id string `json:"id"`

	// IsDeleted States if the exemption is deleted
	IsDeleted *bool `json:"isDeleted,omitempty"`

	// IssueId Issue ID associated with the Exemption
	IssueId string `json:"issueId"`

	// LastModified Unix timestamp at which the resource was most recently modified
	LastModified int64 `json:"lastModified"`

	// Link Link to a related ticket
	Link *string `json:"link,omitempty"`

	// NumOccurrences States how may occurrences are associated with the exemption, if not an issue level exemption
	NumOccurrences *int64 `json:"numOccurrences,omitempty"`

	// Occurrences Array of occurrence Ids
	Occurrences *[]int64 `json:"occurrences,omitempty"`

	// OrgId ID of the Harness Organization to which the exemption applies. Cannot be specified alongside "targetId".
	OrgId *string `json:"orgId,omitempty"`

	// OrgName Name of the organization associated with the exemption
	OrgName        *string        `json:"orgName,omitempty"`
	PendingChanges PendingChanges `json:"pendingChanges"`

	// PipelineId ID of the Harness Pipeline to which the exemption applies. You must also specify "projectId" and "orgId". Cannot be specified alongside "targetId".
	PipelineId *string `json:"pipelineId,omitempty"`

	// ProjectId ID of the Harness Project to which the exemption applies. You must also specify "orgId". Cannot be specified alongside "targetId".
	ProjectId *string `json:"projectId,omitempty"`

	// ProjectName Name of the project associated with the exemption
	ProjectName *string `json:"projectName,omitempty"`

	// Reason Text describing why this Exemption is necessary
	Reason string `json:"reason"`

	// RequesterId User ID of user who requested this exemptions
	RequesterId string `json:"requesterId"`

	// ScanId ID of the Harness Scan to determine all the occurrences for the scan-issue. You must also specify "projectId", "orgId" and "targetId". Cannot be specified alongside "pipelineId".
	ScanId *string `json:"scanId,omitempty"`

	// Scope States the scope for the exemption
	Scope *ExemptionScope `json:"scope,omitempty"`

	// Search Search parameter to find filtered occurrences of the issue
	Search *string `json:"search,omitempty"`

	// Status Approval status of Exemption
	Status ExemptionStatus `json:"status"`

	// TargetId ID of the Target to which the exemption applies. Cannot be specified alongside "projectId" or "pipelineId".
	TargetId *string `json:"targetId,omitempty"`

	// Type Type of Exemption (Compensating Controls / Acceptable Use / Acceptable Risk / False Positive / Fix Unavailable / Other)
	Type ExemptionType `json:"type"`
}

// ExemptionCanApproveFor defines model for Exemption.CanApproveFor.
type ExemptionCanApproveFor string

// ExemptionExemptionStatusAtScan Exemption's status at the Security Scan created time
type ExemptionExemptionStatusAtScan string

// ExemptionScope States the scope for the exemption
type ExemptionScope string

// ExemptionStatus Approval status of Exemption
type ExemptionStatus string

// ExemptionType Type of Exemption (Compensating Controls / Acceptable Use / Acceptable Risk / False Positive / Fix Unavailable / Other)
type ExemptionType string

// FrontendAllIssuesListResponseBody defines model for FrontendAllIssuesListResponseBody.
type FrontendAllIssuesListResponseBody = AllIssuesListResult

// FrontendExemption Exemption summary for frontend use
type FrontendExemption struct {
	// ApproverId User ID of the user who approved this Exemption
	ApproverId *string `json:"approverId,omitempty"`

	// CanApproveFor Scopes that the user has permission to approve for this Exemption
	CanApproveFor *[]FrontendExemptionCanApproveFor `json:"canApproveFor,omitempty"`

	// CanCancel States if the user can cancel the exemption
	CanCancel *bool `json:"canCancel,omitempty"`

	// CanCreate States if the user can create or reopen the exemption
	CanCreate *bool `json:"canCreate,omitempty"`

	// CanReApprove States if the user can re-approve the exemption for the exemption's scope
	CanReApprove *bool `json:"canReApprove,omitempty"`

	// CanReject States if the user can reject the exemption
	CanReject *bool `json:"canReject,omitempty"`

	// Created Unix timestamp at which the resource was created
	Created int64 `json:"created"`

	// Expiration Unix timestamp at which this Exemption will expire
	Expiration *int64 `json:"expiration,omitempty"`

	// Id Resource identifier
	Id string `json:"id"`

	// IsDeleted States if the exemption is deleted
	IsDeleted *bool `json:"isDeleted,omitempty"`

	// IsOccurrenceLevelExemption States if the exemption is an occurrence level exemption
	IsOccurrenceLevelExemption *bool `json:"isOccurrenceLevelExemption,omitempty"`

	// IssueSummary Short summary of an Issue
	IssueSummary IssueSummary `json:"issueSummary"`

	// LastModified Unix timestamp at which the resource was most recently modified
	LastModified int64 `json:"lastModified"`

	// Link Link related to this Exemption
	Link *string `json:"link,omitempty"`

	// NumOccurrences States how may occurrences are associated with the exemption, if not an issue level exemption
	NumOccurrences *int64 `json:"numOccurrences,omitempty"`

	// OrgId ID of the Harness Org to which this Exemption applies
	OrgId          *string        `json:"orgId,omitempty"`
	PendingChanges PendingChanges `json:"pendingChanges"`

	// PipelineId ID of the Harness pipeline to which this Exemption applies
	PipelineId *string `json:"pipelineId,omitempty"`

	// ProjectId ID of the Harness project to which this Exemption applies
	ProjectId *string `json:"projectId,omitempty"`

	// Reason Reason for Exemption
	Reason string `json:"reason"`

	// RequesterId User ID of the user who requested this Exemption
	RequesterId string `json:"requesterId"`

	// Scope The scope of the exemption
	Scope *FrontendExemptionScope `json:"scope,omitempty"`

	// Status Status of this Exemption
	Status string `json:"status"`

	// TargetId ID of Target to which this Exemption applies
	TargetId *string `json:"targetId,omitempty"`

	// TotalOccurrences States total occurrences associated with the issue exemption
	TotalOccurrences *int64 `json:"totalOccurrences,omitempty"`

	// Type Type of Exemption
	Type string `json:"type"`
}

// FrontendExemptionCanApproveFor defines model for FrontendExemption.CanApproveFor.
type FrontendExemptionCanApproveFor string

// FrontendExemptionScope The scope of the exemption
type FrontendExemptionScope string

// FrontendExemptionCounts defines model for FrontendExemptionCounts.
type FrontendExemptionCounts struct {
	// Approved The count of approved Exemptions
	Approved *int32 `json:"Approved,omitempty"`

	// Expired The count of expired Exemptions
	Expired *int32 `json:"Expired,omitempty"`

	// Pending The count of pending Exemptions
	Pending *int32 `json:"Pending,omitempty"`

	// Rejected The count of rejected Exemptions
	Rejected *int32 `json:"Rejected,omitempty"`
}

// FrontendSecurityReviewResponseBody Data needed by the Security Review page
type FrontendSecurityReviewResponseBody = SecurityReviewResult

// GlobalExemptionsRequestBody defines model for GlobalExemptionsRequestBody.
type GlobalExemptionsRequestBody struct {
	// OrgProjectFilter List of organization:project pairs
	OrgProjectFilter *[]string `json:"orgProjectFilter,omitempty"`
}

// IssueSummary Short summary of an Issue
type IssueSummary struct {
	// CurrentStatus Current status of the Exemption
	CurrentStatus *IssueSummaryCurrentStatus `json:"currentStatus,omitempty"`

	// ExemptionCoverage Indicates if the Security Issue was found to be Exempted, Partially Exempted.
	ExemptionCoverage *string `json:"exemptionCoverage,omitempty"`

	// ExemptionId ID of the associated Exemption
	ExemptionId *string `json:"exemptionId,omitempty"`

	// ExemptionStatusAtScan Exemption's status at the Security Scan created time
	ExemptionStatusAtScan *IssueSummaryExemptionStatusAtScan `json:"exemptionStatusAtScan,omitempty"`

	// Id Resource identifier
	Id string `json:"id"`

	// Key Compression/deduplication key
	Key                      string `json:"key"`
	NumNewOccurrences        *int64 `json:"numNewOccurrences,omitempty"`
	NumOccurrences           *int64 `json:"numOccurrences,omitempty"`
	NumRemediatedOccurrences *int64 `json:"numRemediatedOccurrences,omitempty"`

	// OriginStatus The status of the origin, either 'approved' or 'unapproved'
	OriginStatus *string `json:"originStatus,omitempty"`

	// Origins The origin of the issue, either 'app' or 'base'
	Origins *[]string `json:"origins,omitempty"`

	// Override Indicates the issue has been overridden
	Override *map[string]interface{} `json:"override,omitempty"`

	// ScanId The ID of the Scan that detected this Security Issue
	ScanId string `json:"scanId"`

	// Severity Numeric severity, from 0 (lowest) to 10 (highest)
	Severity float32 `json:"severity"`

	// SeverityCode Severity code
	SeverityCode IssueSummarySeverityCode `json:"severityCode"`

	// Status Indicates if the Security Issue was found to be remediated, ignored, etc.
	Status *IssueSummaryStatus `json:"status,omitempty"`

	// TargetVariantName Name of the associated Target and Variant
	TargetVariantName *string `json:"targetVariantName,omitempty"`

	// Title Title of the Security Issue
	Title string `json:"title"`

	// Type The type of vulnerability or quality issue for this Issue
	Type *IssueSummaryType `json:"type,omitempty"`
}

// IssueSummaryCurrentStatus Current status of the Exemption
type IssueSummaryCurrentStatus string

// IssueSummaryExemptionStatusAtScan Exemption's status at the Security Scan created time
type IssueSummaryExemptionStatusAtScan string

// IssueSummarySeverityCode Severity code
type IssueSummarySeverityCode string

// IssueSummaryStatus Indicates if the Security Issue was found to be remediated, ignored, etc.
type IssueSummaryStatus string

// IssueSummaryType The type of vulnerability or quality issue for this Issue
type IssueSummaryType string

// NotFound defines model for NotFound.
type NotFound struct {
	Message string `json:"message"`
	Status  *int64 `json:"status,omitempty"`
}

// Pagination defines model for Pagination.
type Pagination struct {
	// Link Link-based paging
	Link *string `json:"link,omitempty"`

	// Page Page number (starting from 0)
	Page int64 `json:"page"`

	// PageSize Requested page size
	PageSize int64 `json:"pageSize"`

	// TotalItems Total results available
	TotalItems int64 `json:"totalItems"`

	// TotalPages Total pages available
	TotalPages int64 `json:"totalPages"`
}

// PendingChanges defines model for PendingChanges.
type PendingChanges struct {
	// DurationDays The number of days an issue should be exempted for
	DurationDays *int64 `json:"durationDays,omitempty"`
}

// PromoteExemptionRequestBody defines model for PromoteExemptionRequestBody.
type PromoteExemptionRequestBody struct {
	// ApproverId User ID the user who approved or rejected this exemptions
	ApproverId string `json:"approverId"`

	// Comment Comment to be added to the Exemption approval or rejection
	Comment *string `json:"comment,omitempty"`

	// PipelineId Harness STO pipeline ID
	PipelineId *string `json:"pipelineId,omitempty"`

	// TargetId Harness STO Target ID
	TargetId *string `json:"targetId,omitempty"`
}

// SecurityReviewResult Data needed by the Security Review page
type SecurityReviewResult struct {
	Counts FrontendExemptionCounts `json:"counts"`

	// Exemptions Security Review data
	Exemptions []FrontendExemption `json:"exemptions"`
	Pagination Pagination          `json:"pagination"`
}

// ExemptionsPromoteExemptionParams defines parameters for ExemptionsPromoteExemption.
type ExemptionsPromoteExemptionParams struct {
	// AccountId Harness Account ID
	AccountId string `form:"accountId" json:"accountId"`

	// OrgId Harness Organization ID
	OrgId *string `form:"orgId,omitempty" json:"orgId,omitempty"`

	// ProjectId Harness Project ID
	ProjectId *string `form:"projectId,omitempty" json:"projectId,omitempty"`

	// XApiKey Harness personal or service access token
	XApiKey *string `json:"X-Api-Key,omitempty"`
}

// ExemptionsApproveExemptionParams defines parameters for ExemptionsApproveExemption.
type ExemptionsApproveExemptionParams struct {
	// AccountId Harness Account ID
	AccountId string `form:"accountId" json:"accountId"`

	// OrgId Harness Organization ID
	OrgId *string `form:"orgId,omitempty" json:"orgId,omitempty"`

	// ProjectId Harness Project ID
	ProjectId *string `form:"projectId,omitempty" json:"projectId,omitempty"`

	// XApiKey Harness personal or service access token
	XApiKey *string `json:"X-Api-Key,omitempty"`
}

// ExemptionsApproveExemptionParamsAction defines parameters for ExemptionsApproveExemption.
type ExemptionsApproveExemptionParamsAction string

// FrontendAllIssuesListParams defines parameters for FrontendAllIssuesList.
type FrontendAllIssuesListParams struct {
	// AccountId Harness Account ID
	AccountId string `form:"accountId" json:"accountId"`

	// OrgId Harness Organization ID
	OrgId string `form:"orgId" json:"orgId"`

	// ProjectId Harness Project ID
	ProjectId string `form:"projectId" json:"projectId"`

	// Page Page number to fetch (starting from 0)
	Page *int64 `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Number of results per page
	PageSize          *int64  `form:"pageSize,omitempty" json:"pageSize,omitempty"`
	TargetIds         *string `form:"targetIds,omitempty" json:"targetIds,omitempty"`
	TargetTypes       *string `form:"targetTypes,omitempty" json:"targetTypes,omitempty"`
	PipelineIds       *string `form:"pipelineIds,omitempty" json:"pipelineIds,omitempty"`
	ScanTools         *string `form:"scanTools,omitempty" json:"scanTools,omitempty"`
	SeverityCodes     *string `form:"severityCodes,omitempty" json:"severityCodes,omitempty"`
	ExemptionStatuses *string `form:"exemptionStatuses,omitempty" json:"exemptionStatuses,omitempty"`
	Search            *string `form:"search,omitempty" json:"search,omitempty"`
	IssueTypes        *string `form:"issueTypes,omitempty" json:"issueTypes,omitempty"`
}

// FrontendGlobalExemptionsParams defines parameters for FrontendGlobalExemptions.
type FrontendGlobalExemptionsParams struct {
	// AccountId Harness Account ID
	AccountId string `form:"accountId" json:"accountId"`

	// OrgId Harness Organization ID
	OrgId *string `form:"orgId,omitempty" json:"orgId,omitempty"`

	// ProjectId Harness Project ID
	ProjectId *string `form:"projectId,omitempty" json:"projectId,omitempty"`

	// Page Page number to fetch (starting from 0)
	Page *int64 `form:"page,omitempty" json:"page,omitempty"`

	// PageSize Number of results per page
	PageSize *int64 `form:"pageSize,omitempty" json:"pageSize,omitempty"`

	// Status Exemption status
	Status FrontendGlobalExemptionsParamsStatus `form:"status" json:"status"`
	Search *string                              `form:"search,omitempty" json:"search,omitempty"`

	// XApiKey Harness personal or service access token
	XApiKey *string `json:"X-Api-Key,omitempty"`
}

// FrontendGlobalExemptionsParamsStatus defines parameters for FrontendGlobalExemptions.
type FrontendGlobalExemptionsParamsStatus string

// ExemptionsPromoteExemptionJSONRequestBody defines body for ExemptionsPromoteExemption for application/json ContentType.
type ExemptionsPromoteExemptionJSONRequestBody = PromoteExemptionRequestBody

// ExemptionsApproveExemptionJSONRequestBody defines body for ExemptionsApproveExemption for application/json ContentType.
type ExemptionsApproveExemptionJSONRequestBody = ApproveExemptionRequestBody

// FrontendGlobalExemptionsJSONRequestBody defines body for FrontendGlobalExemptions for application/json ContentType.
type FrontendGlobalExemptionsJSONRequestBody = GlobalExemptionsRequestBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ExemptionsPromoteExemptionWithBody request with any body
	ExemptionsPromoteExemptionWithBody(ctx context.Context, id string, params *ExemptionsPromoteExemptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExemptionsPromoteExemption(ctx context.Context, id string, params *ExemptionsPromoteExemptionParams, body ExemptionsPromoteExemptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExemptionsApproveExemptionWithBody request with any body
	ExemptionsApproveExemptionWithBody(ctx context.Context, id string, action ExemptionsApproveExemptionParamsAction, params *ExemptionsApproveExemptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ExemptionsApproveExemption(ctx context.Context, id string, action ExemptionsApproveExemptionParamsAction, params *ExemptionsApproveExemptionParams, body ExemptionsApproveExemptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FrontendAllIssuesList request
	FrontendAllIssuesList(ctx context.Context, params *FrontendAllIssuesListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FrontendGlobalExemptionsWithBody request with any body
	FrontendGlobalExemptionsWithBody(ctx context.Context, params *FrontendGlobalExemptionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FrontendGlobalExemptions(ctx context.Context, params *FrontendGlobalExemptionsParams, body FrontendGlobalExemptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ExemptionsPromoteExemptionWithBody(ctx context.Context, id string, params *ExemptionsPromoteExemptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExemptionsPromoteExemptionRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExemptionsPromoteExemption(ctx context.Context, id string, params *ExemptionsPromoteExemptionParams, body ExemptionsPromoteExemptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExemptionsPromoteExemptionRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExemptionsApproveExemptionWithBody(ctx context.Context, id string, action ExemptionsApproveExemptionParamsAction, params *ExemptionsApproveExemptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExemptionsApproveExemptionRequestWithBody(c.Server, id, action, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExemptionsApproveExemption(ctx context.Context, id string, action ExemptionsApproveExemptionParamsAction, params *ExemptionsApproveExemptionParams, body ExemptionsApproveExemptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExemptionsApproveExemptionRequest(c.Server, id, action, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FrontendAllIssuesList(ctx context.Context, params *FrontendAllIssuesListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFrontendAllIssuesListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FrontendGlobalExemptionsWithBody(ctx context.Context, params *FrontendGlobalExemptionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFrontendGlobalExemptionsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FrontendGlobalExemptions(ctx context.Context, params *FrontendGlobalExemptionsParams, body FrontendGlobalExemptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFrontendGlobalExemptionsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewExemptionsPromoteExemptionRequest calls the generic ExemptionsPromoteExemption builder with application/json body
func NewExemptionsPromoteExemptionRequest(server string, id string, params *ExemptionsPromoteExemptionParams, body ExemptionsPromoteExemptionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExemptionsPromoteExemptionRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewExemptionsPromoteExemptionRequestWithBody generates requests for ExemptionsPromoteExemption with any type of body
func NewExemptionsPromoteExemptionRequestWithBody(server string, id string, params *ExemptionsPromoteExemptionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/exemptions/%s/promote", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accountId", runtime.ParamLocationQuery, params.AccountId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.OrgId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orgId", runtime.ParamLocationQuery, *params.OrgId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "projectId", runtime.ParamLocationQuery, *params.ProjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XApiKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Api-Key", runtime.ParamLocationHeader, *params.XApiKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Api-Key", headerParam0)
		}

	}

	return req, nil
}

// NewExemptionsApproveExemptionRequest calls the generic ExemptionsApproveExemption builder with application/json body
func NewExemptionsApproveExemptionRequest(server string, id string, action ExemptionsApproveExemptionParamsAction, params *ExemptionsApproveExemptionParams, body ExemptionsApproveExemptionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewExemptionsApproveExemptionRequestWithBody(server, id, action, params, "application/json", bodyReader)
}

// NewExemptionsApproveExemptionRequestWithBody generates requests for ExemptionsApproveExemption with any type of body
func NewExemptionsApproveExemptionRequestWithBody(server string, id string, action ExemptionsApproveExemptionParamsAction, params *ExemptionsApproveExemptionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "action", runtime.ParamLocationPath, action)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/exemptions/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accountId", runtime.ParamLocationQuery, params.AccountId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.OrgId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orgId", runtime.ParamLocationQuery, *params.OrgId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "projectId", runtime.ParamLocationQuery, *params.ProjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XApiKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Api-Key", runtime.ParamLocationHeader, *params.XApiKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Api-Key", headerParam0)
		}

	}

	return req, nil
}

// NewFrontendAllIssuesListRequest generates requests for FrontendAllIssuesList
func NewFrontendAllIssuesListRequest(server string, params *FrontendAllIssuesListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/frontend/all-issues/issues")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accountId", runtime.ParamLocationQuery, params.AccountId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orgId", runtime.ParamLocationQuery, params.OrgId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "projectId", runtime.ParamLocationQuery, params.ProjectId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TargetIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "targetIds", runtime.ParamLocationQuery, *params.TargetIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TargetTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "targetTypes", runtime.ParamLocationQuery, *params.TargetTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PipelineIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pipelineIds", runtime.ParamLocationQuery, *params.PipelineIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScanTools != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scanTools", runtime.ParamLocationQuery, *params.ScanTools); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SeverityCodes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "severityCodes", runtime.ParamLocationQuery, *params.SeverityCodes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExemptionStatuses != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "exemptionStatuses", runtime.ParamLocationQuery, *params.ExemptionStatuses); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IssueTypes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "issueTypes", runtime.ParamLocationQuery, *params.IssueTypes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewFrontendGlobalExemptionsRequest calls the generic FrontendGlobalExemptions builder with application/json body
func NewFrontendGlobalExemptionsRequest(server string, params *FrontendGlobalExemptionsParams, body FrontendGlobalExemptionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFrontendGlobalExemptionsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewFrontendGlobalExemptionsRequestWithBody generates requests for FrontendGlobalExemptions with any type of body
func NewFrontendGlobalExemptionsRequestWithBody(server string, params *FrontendGlobalExemptionsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/v2/frontend/exemptions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accountId", runtime.ParamLocationQuery, params.AccountId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.OrgId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "orgId", runtime.ParamLocationQuery, *params.OrgId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ProjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "projectId", runtime.ParamLocationQuery, *params.ProjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pageSize", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, params.Status); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.XApiKey != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "X-Api-Key", runtime.ParamLocationHeader, *params.XApiKey)
			if err != nil {
				return nil, err
			}

			req.Header.Set("X-Api-Key", headerParam0)
		}

	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ExemptionsPromoteExemptionWithBodyWithResponse request with any body
	ExemptionsPromoteExemptionWithBodyWithResponse(ctx context.Context, id string, params *ExemptionsPromoteExemptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExemptionsPromoteExemptionResponse, error)

	ExemptionsPromoteExemptionWithResponse(ctx context.Context, id string, params *ExemptionsPromoteExemptionParams, body ExemptionsPromoteExemptionJSONRequestBody, reqEditors ...RequestEditorFn) (*ExemptionsPromoteExemptionResponse, error)

	// ExemptionsApproveExemptionWithBodyWithResponse request with any body
	ExemptionsApproveExemptionWithBodyWithResponse(ctx context.Context, id string, action ExemptionsApproveExemptionParamsAction, params *ExemptionsApproveExemptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExemptionsApproveExemptionResponse, error)

	ExemptionsApproveExemptionWithResponse(ctx context.Context, id string, action ExemptionsApproveExemptionParamsAction, params *ExemptionsApproveExemptionParams, body ExemptionsApproveExemptionJSONRequestBody, reqEditors ...RequestEditorFn) (*ExemptionsApproveExemptionResponse, error)

	// FrontendAllIssuesListWithResponse request
	FrontendAllIssuesListWithResponse(ctx context.Context, params *FrontendAllIssuesListParams, reqEditors ...RequestEditorFn) (*FrontendAllIssuesListResponse, error)

	// FrontendGlobalExemptionsWithBodyWithResponse request with any body
	FrontendGlobalExemptionsWithBodyWithResponse(ctx context.Context, params *FrontendGlobalExemptionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FrontendGlobalExemptionsResponse, error)

	FrontendGlobalExemptionsWithResponse(ctx context.Context, params *FrontendGlobalExemptionsParams, body FrontendGlobalExemptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*FrontendGlobalExemptionsResponse, error)
}

type ExemptionsPromoteExemptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Exemption
	JSON400      *NotFound
	JSON401      *NotFound
	JSON403      *NotFound
	JSON404      *NotFound
	JSON429      *NotFound
	JSON500      *NotFound
}

// Status returns HTTPResponse.Status
func (r ExemptionsPromoteExemptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExemptionsPromoteExemptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExemptionsApproveExemptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Exemption
	JSON400      *NotFound
	JSON401      *NotFound
	JSON403      *NotFound
	JSON404      *NotFound
	JSON429      *NotFound
	JSON500      *NotFound
}

// Status returns HTTPResponse.Status
func (r ExemptionsApproveExemptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExemptionsApproveExemptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FrontendAllIssuesListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FrontendAllIssuesListResponseBody
	JSON400      *NotFound
	JSON401      *NotFound
	JSON403      *NotFound
	JSON404      *NotFound
	JSON429      *NotFound
	JSON500      *NotFound
}

// Status returns HTTPResponse.Status
func (r FrontendAllIssuesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FrontendAllIssuesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FrontendGlobalExemptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FrontendSecurityReviewResponseBody
	JSON400      *NotFound
	JSON401      *NotFound
	JSON403      *NotFound
	JSON429      *NotFound
	JSON500      *NotFound
}

// Status returns HTTPResponse.Status
func (r FrontendGlobalExemptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FrontendGlobalExemptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ExemptionsPromoteExemptionWithBodyWithResponse request with arbitrary body returning *ExemptionsPromoteExemptionResponse
func (c *ClientWithResponses) ExemptionsPromoteExemptionWithBodyWithResponse(ctx context.Context, id string, params *ExemptionsPromoteExemptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExemptionsPromoteExemptionResponse, error) {
	rsp, err := c.ExemptionsPromoteExemptionWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExemptionsPromoteExemptionResponse(rsp)
}

func (c *ClientWithResponses) ExemptionsPromoteExemptionWithResponse(ctx context.Context, id string, params *ExemptionsPromoteExemptionParams, body ExemptionsPromoteExemptionJSONRequestBody, reqEditors ...RequestEditorFn) (*ExemptionsPromoteExemptionResponse, error) {
	rsp, err := c.ExemptionsPromoteExemption(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExemptionsPromoteExemptionResponse(rsp)
}

// ExemptionsApproveExemptionWithBodyWithResponse request with arbitrary body returning *ExemptionsApproveExemptionResponse
func (c *ClientWithResponses) ExemptionsApproveExemptionWithBodyWithResponse(ctx context.Context, id string, action ExemptionsApproveExemptionParamsAction, params *ExemptionsApproveExemptionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ExemptionsApproveExemptionResponse, error) {
	rsp, err := c.ExemptionsApproveExemptionWithBody(ctx, id, action, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExemptionsApproveExemptionResponse(rsp)
}

func (c *ClientWithResponses) ExemptionsApproveExemptionWithResponse(ctx context.Context, id string, action ExemptionsApproveExemptionParamsAction, params *ExemptionsApproveExemptionParams, body ExemptionsApproveExemptionJSONRequestBody, reqEditors ...RequestEditorFn) (*ExemptionsApproveExemptionResponse, error) {
	rsp, err := c.ExemptionsApproveExemption(ctx, id, action, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExemptionsApproveExemptionResponse(rsp)
}

// FrontendAllIssuesListWithResponse request returning *FrontendAllIssuesListResponse
func (c *ClientWithResponses) FrontendAllIssuesListWithResponse(ctx context.Context, params *FrontendAllIssuesListParams, reqEditors ...RequestEditorFn) (*FrontendAllIssuesListResponse, error) {
	rsp, err := c.FrontendAllIssuesList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFrontendAllIssuesListResponse(rsp)
}

// FrontendGlobalExemptionsWithBodyWithResponse request with arbitrary body returning *FrontendGlobalExemptionsResponse
func (c *ClientWithResponses) FrontendGlobalExemptionsWithBodyWithResponse(ctx context.Context, params *FrontendGlobalExemptionsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FrontendGlobalExemptionsResponse, error) {
	rsp, err := c.FrontendGlobalExemptionsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFrontendGlobalExemptionsResponse(rsp)
}

func (c *ClientWithResponses) FrontendGlobalExemptionsWithResponse(ctx context.Context, params *FrontendGlobalExemptionsParams, body FrontendGlobalExemptionsJSONRequestBody, reqEditors ...RequestEditorFn) (*FrontendGlobalExemptionsResponse, error) {
	rsp, err := c.FrontendGlobalExemptions(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFrontendGlobalExemptionsResponse(rsp)
}

// ParseExemptionsPromoteExemptionResponse parses an HTTP response from a ExemptionsPromoteExemptionWithResponse call
func ParseExemptionsPromoteExemptionResponse(rsp *http.Response) (*ExemptionsPromoteExemptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExemptionsPromoteExemptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Exemption
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseExemptionsApproveExemptionResponse parses an HTTP response from a ExemptionsApproveExemptionWithResponse call
func ParseExemptionsApproveExemptionResponse(rsp *http.Response) (*ExemptionsApproveExemptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExemptionsApproveExemptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Exemption
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseFrontendAllIssuesListResponse parses an HTTP response from a FrontendAllIssuesListWithResponse call
func ParseFrontendAllIssuesListResponse(rsp *http.Response) (*FrontendAllIssuesListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FrontendAllIssuesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FrontendAllIssuesListResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseFrontendGlobalExemptionsResponse parses an HTTP response from a FrontendGlobalExemptionsWithResponse call
func ParseFrontendGlobalExemptionsResponse(rsp *http.Response) (*FrontendGlobalExemptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FrontendGlobalExemptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FrontendSecurityReviewResponseBody
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}
